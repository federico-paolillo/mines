# Project: mines

## General information

It is a client-server Minesweeper clone.

### Backend

The server is written in Go 1.25 and exposes an HTTP API that will be invoked by a frontend (the client, yet to be implemented). It features an Open API specification that will be the contract consumed by the frontend. A peculiarity of this implementation is that each game of Minesweeper has a TTL of 2 hours maximum. Each game can be created and adressed with a reasonably unique identifier. Concurrency controls features have been implemented using an optimistic offline lock. The goal is to ensure that the frontend can issue multiple moves from different instances of the same frontend. The project has a custom in-memory and in-process game store and a memcached-based as store for all games (durability of the game data is a non-goal). We use memcached to make the server scalable across multiple replicas, taking advantage of memcached TTL mechanism for garbage collection and CAS id for concurrency control. The game server can be configured using environment variables or a YAML file (see config.example.yml). Coding style is enforce through golangci-lint and related configuration (see .golangci.yml). Lefthook is used as the task runner (see lefthook.yml). The file package.json exists solely to keep track of the Gemini CLI version and has no other purpose than to scope a Gemini CLI version to this project. Tests are written using the built-in Go testing framework and use `testify` to simplify writing assertions.

### Frontend

Frontend code is with the `fe/` folder. It is a Preact project with `preact-iso` as Router. Tailwind CSS is used for styling. The underlying build tool is Vite. The project structure is very thin and separates between `pages/` (routable top level components) and `components/` (UI widgets and pieces of interactable content). Biome is the linter/formatter tool of choice.

## Project structure

The backend project structure takes loose inspiration from [https://github.com/golang-standards/project-layout](Golang Standards: Project Layout). Main executables are within the `/cmd` folder. `/cmd/server` is the main executable for the HTTP Server with the game logic. `/bin` contains executables using during development (all are code generators). `/docs` contains the Open API specification automatically generated by swag when invoked via CLI. `internal/` has most application logic and server related functionality. `pkg/` contains the domain of the project with all Minesweeper related data structures and the actual Minesweeper game logic.

The frontend project structure is withing the `fe/` folder and follows a default Preact project with Vite and Vitest. Routable pages are in the `pages/` folder. Each page-related component is within a given page `components/` folder. For example: Home page only components are under `pages/Home/components/`. General, shareable components, are in the `components/` top-level folder. The folder `client/` is gitignored and is automatically generated by using the Kiota tool that will consume the Open API specification produced by the Swag tool.

## Interesting backend pieces

### pkg/mines/mines.go

This is the composition root in the dependency injection sense: a Composition Root is a (preferably) unique location in an application where modules are composed together. It is a bag of objects that carries all services and other injectables that can be used by the application code. Because we cannot really perform everywhere constructor injection, we pass this composition root around very much like Go's `context.Context`. This pattern is commonly found in many Go applications.

### pkg/mines/config/config.go

This is the definition of the application configuration along with default values. The file `load.go` uses the library `configuro` to read environment variables, files and defaults to produce a complete configuration object.

### internal/storage

This folder contains all that is needed to save games state. The productive implementation will use memcached (see `internal/storage/memcached`). We will use the in-memory storage only for testing and local development. Integration tests for memcached used `Testcontainers` configured for Podman on MacOS. 

## Interesting frontend pieces

Nothing particular. The implementation is pretty barebone at this time.

## Requirements

To run Go tests you will need a Podman instance running on MacOS. Otherwise, by setting env. var. CI=true, you can use Docker. You also need NodeJS v21 to run the frontend. Lefthook is the task-runner of choice but some frontend only npm scripts are available in the package.json within the `fe/` folder. Ignore the project root `package.json` it is only needed for the Gemini CLI.