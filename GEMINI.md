# Project: mines

## General information

It is a client-server Minesweeper clone. The server is written in Go 1.25 and exposes an HTTP API that will be invoked by a frontend (the client, yet to be implemented). It features an Open API specification that will be the contract consumed by the frontend. A peculiarity of this implementation is that each game of Minesweeper has a TTL of 2 hours maximum. Each game can be created and adressed with a reasonably unique identifier. Concurrency controls features have been implemented using an optimistic offline lock and common Go cncurrency primitives. The goal is to ensure that the frontend can issue multiple moves from different instances of the same frontend. The project has a custom in-memory and in-process game store and a memcached-based as store for all games (durability of the game data is a non-goal). We use memcached to make the server scalable across multiple replicas, taking advantage of memcached TTL mechanism for garbage collection and CAS id for concurrency control. The game server can be configured using environment variables or a YAML file (see config.example.yml). Coding style is enforce through golangci-lint and related configuration (see .golangci.yml). Lefthook is used as the task runner (see lefthook.yml). The file package.json exists solely to keep track of the Gemini CLI version and has no other purpose than to scope a Gemini CLI version to this project. Tests are written using the built-in Go testing framework and use `testify` to simplify writing assertions.

Frontend code is with the `fe/` folder. It is a Preact project with `preact-iso` as Router. Tailwind CSS is used for styling. The underlying build tool is Vite. The project structure is very thin and separates between `pages/` (routable top level components) and `components/` (UI widgets and pieces of interactable content). Biome is the linter/formatter tool of choice.

## Project structure

The project structure takes loose inspiration from [https://github.com/golang-standards/project-layout](Golang Standards: Project Layout). Main executables are within the `/cmd` folder. `/cmd/server` is the main executable for the HTTP Server with the game logic. `/bin` contains executables using during development (all are code generators). `/docs` contains the Open API specification automatically generated by swag when invoked via CLI. `internal/` has most application logic and server related functionality. `pkg/` contains the domain of the project with all Minesweeper related data structures and the actual Minesweeper game logic.

## Interesting Components

### pkg/mines/mines.go

This is the composition root in the dependency injection sense: a Composition Root is a (preferably) unique location in an application where modules are composed together. It is a bag of objects that carries all services and other injectables that can be used by the application code. Because we cannot really perform everywhere constructor injection, we pass this composition root around very much like Go's `context.Context`. This pattern is commonly found in many Go applications.

### pkg/mines/config/config.go

This is the definition of the application configuration along with default values. The file `load.go` uses the library `configuro` to read environment variables, files and defaults to produce a complete configuration object.

### internal/storage

This folder contains all that is needed to save games state. The productive implementation will use memcached (see `internal/storage/memcached`). We will use the in-memory storage only for testing and local development. Integration tests for memcached used `Testcontainers` configured for Podman on MacOS. 